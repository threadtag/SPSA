# license BSDL2
# Author: Hengyi Jiang <hengyi.jiang@gmail.com> <jhy@fudan.edu.cn>
# purpose:to read a fragment of a big fasta file, which include multiple fasta sequences 
# this script requires index information of the genome has been imported into mysql database
# !! fasta_index should be generated by fasta_index.rb 
# target_file should be csv file
# JHY @ fudan 2018-05-24, 2018-07-13 bug fix
# 2019-09-18 update with option parser

require 'mysql2'
require 'optparse'
require 'yaml'

usage=<<EOF
purpose:to read a fragment of a big fasta file, which include multiple fasta sequences
note: this script requires index information of the genome has been imported into mysql database
usage:ruby fasta_snippet_mysql.rb [option]  target_file.csv
      target_file.csv is the colon seperated file
      offset starting from 0
options:
-k database config file path
-p fasta_file_path
-m margin
-u upstream to include
-d downstream to include
-e entry_id in the target file
-g genome offset in the target file
-l left offset in the target file
-r right offset in the target file
-f forward? offset in the target file
-F Field seperator, default is :
example:    
	  ruby fasta_snippet_mysql.rb -k db_config.yaml -p /home/database/Bacteria.fna -e 0 -g 1 -l 2 -r 3 -f 4 -u 1000 -F : list.csv > target.fasta
EOF

# _left _right is offset value, starting from 0
# _start _end is fasta postion indicator, starting from 1
def pos_convert(fasta_pos,seq_left, width)
	# convert fasta_pos to text file offset
	# seq_left is offset of the first letter of sequence
	# each line end with \n, which is one character
	lines= fasta_pos.to_i / width.to_i
	if fasta_pos.to_i % width == 0
		fasta_pos.to_i+seq_left.to_i-1 + lines-1
	else
		fasta_pos.to_i+seq_left.to_i-1 + lines
	end
end

def reverse_complement(seq)
	replace_map ={'A'=>"T","C"=>"G","T"=>"A","G"=>"C","a"=>'t','c'=>'g','t'=>'a','g'=>'c',"\n"=>""}
	r=seq.reverse
 	r.gsub(Regexp.union(replace_map.keys), replace_map)
end


if(ARGV.size <1)
	puts usage
	abort
	#raise ArgumentError,usage
end

# option parsing
option={}
OptionParser.new do |opts|
	opts.banner = "Usage: ruby fasta_snippet_mysql.rb [option] target_file"
	opts.on("-k dbconfig_path","--database_key dbk","dbconfig yaml file path") do |v|
		option[:db]=v
	end

	opts.on("-F seperator","--FS","Field seperator") do |v|
		option[:fs]=v
	end
	opts.on("-p database","--path database","fasta file path") do |v|
		option[:path]=v
	end
	opts.on("-m mg","--margin mg","expand the margin of the target by mg bp") do |v|
		option[:margin]=v
	end
	
	opts.on("-e id","--entry_id id","entry_id offset") do |v|
		option[:entry_id]=v
	end
	opts.on("-g g_offset","--genome_off g_offset","g_offset") do |v|
		option[:genome]=v
	end
	opts.on("-l left_off","--left left_off","left_offset") do |v|
		option[:left]=v
	end

	opts.on("-r right_off","--right right_off","right_offset") do |v|
		option[:right]=v
	end
	opts.on("-f forward_off","--forward_off forward_off") do |v|
		option[:forward]=v
	end
	opts.on("-u ups","--upstream ups","upstream ups bp [5'--utr]") do |v|
		option[:upstream]=v
	end
	opts.on("-d ds","--downstream ds","upstream ups bp [3'--utr]") do |v|
		option[:downstream]=v
	end

	#  (..[.....|____|......]..)
	#    |   |          |    |
	#mg _|   up        down  |__ margin
end.parse!


# change database connection parameters in the config file
if !option.has_key?(:db)
	puts "please specify the database config file  with -k or --database_key option"
	abort
else
	if File.exists?(option[:db])
		db_config=YAML.load(File.open(option[:db]))
		db_user = db_config['db_user']
		db_pass = db_config['db_password']
		db_name = db_config['db_name']
	else
		puts "database config file #{option[:db]} not found"
		abort
	end
end


if !option.has_key?(:path)
	puts "please specify the fasta file path with -p or --path option"
	abort
else
	fasta_file  = option[:path]
end

if option.has_key?(:margin)
	if(!option[:margin].match(/^\d+$/))
		puts ("margin should be number:#{usage}")
		abort
	end
	margin = option[:margin].to_i
else
	margin=0
end

if option.has_key?(:upstream)
	if(!option[:upstream].match(/^\d+$/))
		puts ("upstream should be number:#{usage}")
		abort
	end
	upstream=option[:upstream].to_i
else
	upstream = 0
end

if option.has_key?(:downstream)
	if(!option[:downstream].match(/^\d+$/))
		puts ("downstream should be number:#{usage}")
		abort
	end
	downstream=option[:downstream].to_i
else
	downstream = 0
end

if option.has_key?(:fs)
	delim=option[:fs]
else
	delim=":"
end



if option.has_key?(:entry_id)
	if option[:entry_id].match(/\d+/)
		entry_id=option[:entry_id].to_i
	else
		puts "option -e / --entry_id should be digit, starting from 0"
		abort
	end
else
	entry_id=0
end

if option.has_key?(:genome)
	if option[:genome].match(/\d+/)
		genome_off=option[:genome].to_i
	else
		puts "option -g / --genome_off should be digit, starting from 0"
		abort
	end
else
	genome_off=entry_id
end

if option.has_key?(:left)
	if option[:left].match(/\d+/)
		left=option[:left].to_i
	else
		puts "option -l / --left should be digit, starting from 0"
		abort
	end
else
	left=2
end
if option.has_key?(:right)
	if option[:right].match(/\d+/)
		right=option[:right].to_i
	else
		puts "option -r / --right should be digit, starting from 0"
		abort
	end
else
	right=3
end


if option.has_key?(:forward)
	if option[:forward].match(/\d+/)
		forward=option[:forward].to_i
	else
		puts "option -f / --forward_off should be digit, starting from 0"
		abort
	end
else
	forward=4
end




target_file = ARGV.shift

client = Mysql2::Client.new(
	:host     => 'localhost', # 主机
	:username => db_user,      # 用户名
	:password => db_pass,    # 密码
	:database => db_name,      # 数据库
	:encoding => 'utf8'       # 编码
)


# packing target_seq into an array
begin
	tf=File.open(target_file)
rescue
	puts "target_file open failed"
	puts "#{usage}"
end
target = Array.new

tf.each do |l|
	m=l.chomp.split(/#{delim}/)
	if m.size <right + 1		
		puts "target file fields do not match -r option"
		abort
	else
		# check interger
		if option.has_key? (:entry_id)
			if m[entry_id].match(/\.\d$/)
				seq_name=m[entry_id]
			else
				seq_name = m[entry_id]+".1"
			end
		else
			if mm= m[0].match(/>(\S+?(.1)?)\s+\S+/)
				if mm[2]==nil
					seq_name =mm[1]+".1"
				else
					seq_name = mm[1]
				end
			else
				seq_name =m[0]
			end
		end

		if option.has_key?(:forward)
			target.push([seq_name,m[genome_off],m[left].to_i, m[right].to_i,m[forward] ])	
		else
			target.push([seq_name,m[genome_off],m[left].to_i, m[right].to_i] )
		end
	end
end
tf.close

begin
	fasta = File.new(fasta_file)
rescue
	puts ("usage:#{usage}")
	raise 'fasta_file open failed'
	
end


target.each do |t|
	target_seq = t[0]
	target_genome=t[1]
	target_start = t[2]
	target_end = t[3]

	if t.size ==5
		if t[4]=='1' or  t[4].match(/true/i)
			is_reverse=false
		else
			is_reverse = true
		end
	else
		if(target_start > target_end)
			# cut seq on the reverse strand
			is_reverse = true
		else
			is_reverse = false
		end
	end

	#start to determine the IO offset
	# _left _right is offset value, starting from 0
	# _start _end is fasta postion indicator, starting from 1

	# begin to query mysql database
	if target_seq.include?(" ")
		sql = "select * from fasta_info where seq_name like(\"#{target_seq}%\")"
	else
		sql="select * from fasta_info where seq_id = \"#{target_seq}\""
	end
	
	# todo: using index of the table boost the query
	begin
		result=client.query(sql)
	rescue
		puts "error query #{sql}"
		next
	end

	if(result.count ==0)
		puts "target_seq:#{target_seq} not found"
		next
	end

	left =""
	right =""
	seq_left=""
	width =""
	result.each do |item|
		left=item['fasta_left']
		right=item['fasta_right']
		seq_left = item['seq_left']
		width = item['line_width']
		break
	end

	if target_start > target_end
		tmp=target_start
		target_start =target_end
		target_end = tmp
		tmp =""
	end
	
	
    genome_char_count = right.to_i-seq_left.to_i+1
	if genome_char_count%width.to_i==0
		genome_line_count = genome_char_count/(width.to_i+1)
	else
		genome_line_count = (genome_char_count/(width.to_i+1)) +1
	end

	genome_size = genome_char_count- genome_line_count

 	# target_start, target_end: 相对于序列来讲的,不是file 的offset, 
	# _start 在前, _end在后, _start 最小为1, _end 最大为genome_size
	# target_start, target_end: relative the sequence start, 
	# _start being smaller than _end, 
	# smallest value for _start 1, biggest value for _end is genome_size
	if is_reverse 
		# 是否是 reverse控制upstream 和downstream的定义
		# the value of reverse determines the definition of upstream and downstream
		
		if target_start - margin -downstream >0
			target_start = target_start - margin -downstream 
		else
			target_start =1
		end

		if target_end+margin+upstream >genome_size
			target_end = genome_size
		else
			target_end = target_end+margin+upstream
		end
	else
		# puts "forward"
		if target_start - margin -upstream >0
			target_start = target_start - margin -upstream 
		else
			target_start =1
		end

		if target_end+margin+downstream >genome_size
			target_end = genome_size
		else
			target_end = target_end+margin+downstream
		end
	end

	# target_left, target_right: 相对于文件的offset 来讲的
	# target_left, target_right: relative to the File start offset(0)
	target_left = pos_convert(target_start, seq_left, width)
	target_right= pos_convert(target_end, seq_left, width)
	
	if (target_left > right)
		puts  "\n!!target_left out of the range of genome\n\n"
		next
	end

	if(target_right > right)
		puts "\n!! target_right is out of range of genome, adjusting to end of the genome\n"	
		target_right =right-1
	end
	fasta.seek(target_left, IO::SEEK_SET)
	snippet=fasta.read(target_right-target_left+1);
	
	if(is_reverse)
		puts ">#{target_seq} [#{target_genome}(#{t[2]},#{t[3]})]_rv_#{target_start}_#{target_end}"
		puts reverse_complement(snippet)
	else
		puts ">#{target_seq} [#{target_genome}(#{t[2]},#{t[3]})]_fw_#{target_start}_#{target_end}"
		puts snippet
	end
end 
